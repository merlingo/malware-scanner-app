#include "Model.h"
Model::Model()
{
}
Model::Model(int ss) {
	space_size = ss;
	for (int i = 0; i < familyLength; i++) {
		GraphModel mg(space_size, (Family)i);
		ms.push_back(mg);
	}
}
double Model::mean(Matrix<int> data)
{
	double sum = 0.0;
	for (int i = 0; i < space_size; i++)
		for (int j = 0; j < space_size; j++)
		{
			sum += data[i][j];
		}
	return sum / space_size * space_size;
}
double Model::cov(Matrix<int> a, Matrix<int> b, double meana, double meanb) {
	//Correlation coefficient
	double sum = 0;

	for (int i = 0; i < space_size; i++)
		for (int j = 0; j < space_size; j++)
		{
			sum += (a[i][j] - meana)*(b[i][j] - meanb);
		}

	return sum;
}
double Model::var(Matrix<int> data, double meandata)
{
	double sum = 0;
	for (int i = 0; i < space_size; i++)
		for (int j = 0; j < space_size; j++)
		{
			sum += pow(data[i][j] - meandata, 2);
		}
	return sum;
}
double Model::correlation_coefficient(Matrix<int> a, Matrix<int> b)
{
	double meana = mean(a);
	double meanb = mean(b);
	return (cov(a, b, meana, meanb)) / (sqrt(var(a, meana)*var(b, meanb)));
}

int Model::largest(double arr[], int n)
{
	int i;

	// Initialize maximum element 
	double max = arr[0];
	int m_ind = 0;
	// Traverse array elements  
	// from second and compare 
	// every element with current max  
	for (i = 1; i < n; i++)
		if (arr[i] > max) {
			max = arr[i];
			m_ind = i;
		}

	return m_ind;
}

void Model::train(vector<Opcode_seq> &dataset) //input olarak verisetini yani opcode sequence listesini almalýdýr.
{
	//dataset'deki opcode_seq'leri ailelerine gore ayirip ait oldugu aile icin egitim yapilmalidir. eger ms listesindeki aile ile siradaki opcode_seq'in ailesi eslesiyorsa o aileye atanmalidir.
	vector<Opcode_seq>::iterator ptr;
	for (ptr = dataset.begin(); ptr < dataset.end(); ptr++)
	{
		trainWitOne((*ptr));
		//ms[Benign].addEdge(ptr->sequence[0], ptr->sequence[1]); // for each opcode pair in unique list
	}
}
void Model::trainWitOne(Opcode_seq &sample) {
	//for each opcode_seq Benign, Mwor, NGVCK, PSMPC, G2, first check family, then find its graph model, then train this model.
	GraphModel *mg_pointer = NULL;
	switch (sample.family) {
	case Benign:
		mg_pointer = &ms[Benign];
		break;
	case MWOR:
		mg_pointer = &ms[MWOR];

		break;
	case NGVCK:
		mg_pointer = &ms[NGVCK];

		break;
	case PSMPC:
		mg_pointer = &ms[PSMPC];

		break;
	case G2:
		mg_pointer = &ms[G2];

		break;
	default:
		break;
	}
	if (mg_pointer == NULL)
		throw;
	//TO DO:
	sample.change_to_unique();
	list<Opcode>::iterator i;
	for (i = sample.sequence.begin(); i != (sample.sequence.end()); i++) {
		list<Opcode>::iterator j;
		for (j = i; j != sample.sequence.end(); j++) {
			mg_pointer->addEdge((*i), (*j));
		}
	}
}
//
Family Model::test(Opcode_seq sample, double* &results) {
	// Declaring iterator to a vector 
	vector<GraphModel>::iterator ptr;
	if (results != NULL)
		delete[] results;
	results = new double[familyLength]; //CAUTION!!!!!!!!!!!!!!!!!!!!!! THE RESULT ARRAY SHOULD BE DELETED WHERE IT create. It must be created with NULL pointer.
	Matrix<int> msample = opseq_to_Matrix(sample);
	for (ptr = ms.begin(); ptr != ms.end(); ptr++)
	{
		results[ptr->getFamily()] = correlation_coefficient(ptr->adj_matrix(), msample);
		//cout << endl;
	}
	return (Family)largest(results, familyLength);
}

void Model::exportModel(string filename) {
	ofstream myfile(filename);
	if (myfile.is_open())
	{
		myfile << to_string(space_size).c_str() << endl;
		for (auto m : ms) {
			myfile << m.getFamily() << endl;
			//HOW TO EXPORT/IMPORT MODEL : model is a graph. so we need to export its adj vector and import its adj matrix, each row express 
			Matrix<int> matrix = m.adj_matrix();
			for (int i = 0; i < m.getN(); i++) {
				for (int j = 0; j < m.getN(); j++)
				{
					myfile << matrix[i][j];
					if (i*j != (space_size - 1)*(space_size - 1)) {
						myfile << ",";
					}

				}

				//
			}
			myfile << endl;
		}
		myfile.close();
	}
	else cout << "Unable to open file";
}
Model Model::importModel(string filename) {
	int ss; // read from file
	//read file
	string line;
	ifstream myfile(filename);
	Model m(0);
	Family f = Benign;
	if (myfile.is_open())
	{
		int line_num = 0;
		while (getline(myfile, line))
		{
			//cout << line << '\n';
			if (line_num == 0) {		//first import state space

				ss = atoi(line.c_str());
				m = Model(ss);
			} //Benign, Mwor, NGVCK, PSMPC, G2
			else if (line_num % 2 == 1)
			{
				f = (Family)atoi(line.c_str());
			}
			else if (line_num % 2 == 0) { //2 family is Mwor
				vector<string> line_values = split(line, ","); //tum degerler ayni row'da alinir. NxN lik vector olusur. bu vectorde matrix degerleri vardir. 
				Matrix<int> matrix(ss, ss);
				for (int i = 0; i < ss; i++) {
					for (int j = 0; j < ss; j++)
						matrix[i][j] = atoi(line_values[i*ss + j].c_str());
				}
				GraphModel gm(ss, f);
				gm.setMatrix(matrix);
				m.pushGraphModel(gm, f);
			}
			line_num++;
		}
		myfile.close();
	}
	else cout << "Unable to open file";


	return m;
}

Model::~Model()
{
}

vector<string> split(string s, string delimiter) {
	size_t pos_start = 0, pos_end, delim_len = delimiter.length();
	string token;
	vector<string> res;

	while ((pos_end = s.find(delimiter, pos_start)) != string::npos) {
		token = s.substr(pos_start, pos_end - pos_start);
		pos_start = pos_end + delim_len;
		res.push_back(token);
	}

	res.push_back(s.substr(pos_start));
	return res;
}
