#include "metamal_detect_process.h"



MetamalDetectProcess::MetamalDetectProcess()
{
}

bool MetamalDetectProcess::step(File & filename)
{
	//get opcode sequence and apply model.detection
	Model m = Model::importModel(modelfilename);

	Opcode_seq seq = get_op(filename.name, allOpCodes);
	double *r=NULL;
	Family tresult = m.test(seq, r);
	if (tresult == Benign)
	{
		filename.ft = BENIGN;
		return false;
	}
	else {
		filename.ft = DETECTED;
		return true;
	}
}

int MetamalDetectProcess::allOpcodesBuilding( string opcode)
{
	int order = 0;
	vector<string>::iterator it = std::find(allOpCodes.begin(), allOpCodes.end(), opcode);
	if (it == allOpCodes.end()) {//"Element not found"
		order = allOpCodes.size();
		allOpCodes.push_back(opcode);
	}
	else
		order = distance(allOpCodes.begin(), it);
	return order;
}

Family MetamalDetectProcess::getFamily(const string & fn){
	//if(strstr(s1.c_str(), s2.c_str()))
	if (contain(fn, "BENIGN"))
		return Benign;
	if (contain(fn, "MWOR"))
		return MWOR;
	if (contain(fn, "NGVCK"))
		return NGVCK;
	if (contain(fn, "G2"))
		return PSMPC;
	if (contain(fn, "PSMPC"))
		return G2;
	else
		throw;
}

Opcode_seq MetamalDetectProcess::get_op(const string & fn, vector<string>& allOpCodes)
{ //NEED TO WRITE IMPORT AND EXPORT FUNCTIONS FOR ALLOPPCODES BY USING A FILE.
	//Read
	size_t s;
	ifstream infile(fn, std::ios::binary);
	infile.seekg(0, infile.end);
	s = infile.tellg();
	infile.seekg(0, infile.beg);
	Opcode_seq opseq;
	string delimiter = " ";
	int i = 0;
	while (!infile.eof())
	{
		char data[BUFFSIZE];
		//infile.read(reinterpret_cast<char*> (&vec[1]), s * sizeof(vec[1]));
		infile.read(data, BUFFSIZE);
		// Initialize decoder context
		ZydisDecoder decoder;
		ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LEGACY_32, ZYDIS_ADDRESS_WIDTH_32);

		// Initialize formatter. Only required when you actually plan to do instruction
		// formatting ("disassembling"), like we do here
		ZydisFormatter formatter;
		ZydisFormatterInit(&formatter, ZYDIS_FORMATTER_STYLE_INTEL);

		// Loop over the instructions in our buffer.
		// The runtime-address (instruction pointer) is chosen arbitrary here in order to better
		// visualize relative addressing
		ZyanU64 runtime_address = 0x10001000;
		ZyanUSize offset = 0;
		const ZyanUSize length = BUFFSIZE;
		//const ZyanUSize length = sizeof(data);
		ZydisDecodedInstruction instruction;
		while (ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, data + offset, length - offset,
			&instruction)))
		{
			// Print current instruction pointer.
			//printf("%016" PRIX32 "  ", runtime_address);
			// Format & print the binary instruction structure to human readable format
			char buffer[128];
			ZydisFormatterFormatInstruction(&formatter, &instruction, buffer, sizeof(buffer),
				runtime_address);
			//puts(buffer);
			string ins_str(buffer);

			string opcs = ins_str.substr(0, ins_str.find(delimiter));
			int order = allOpcodesBuilding(opcs);
			//TO-DO: allOpCodes should be exported to file. It needs to be imported file. If file doesn't exist it should be NULL

			Opcode opcode = { opcs, instruction.opcode,order };

			opseq.sequence.push_back(opcode);
			opseq.family = getFamily(fn);
			i++;
			offset += instruction.length;
			runtime_address += instruction.length;
		}
	}
	return opseq;
}

void MetamalDetectProcess::resize(int size, int *& arr)
{
	size_t newSize = size * 2;
	int* newArr = new int[newSize];
	memcpy(newArr, arr, size * sizeof(int));
	size = newSize;
	delete[] arr;
	arr = newArr;
}

bool MetamalDetectProcess::contain(string s1, string s2) {
	if (s1.find(s2) != std::string::npos)
		return true;
	else
		return false;
}


MetamalDetectProcess::~MetamalDetectProcess()
{
}
