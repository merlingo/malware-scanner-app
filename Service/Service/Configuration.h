#pragma once
#ifndef CONF_H_
#define CONF_H_
#include<string>
#include<list>
using namespace std;
static string hashfilename = "";
static string modelfilename = "";
static int familyLength = 5;

struct Opcode
{
	string opname;
	char byte_val;
	int order; // olusturulan o buyuk opcode listesindeki sirasi - mapping ile bir dictionary kullanilabilirdi ama bu daha kolay olur diye böyle yaptik.
	inline bool operator==(const Opcode& lhs)
	{
		return lhs.opname == this->opname;
	}
};
enum Family {
	Benign, MWOR, NGVCK, PSMPC, G2
};
inline bool equalence_of_opcodes(Opcode first, Opcode second) {
	return (first.order == second.order);
}
// comparison, not case sensitive.
inline bool compare_opcodes(const Opcode& first, const Opcode& second)
{

	return (first.order < second.order);
}
struct Opcode_seq {
	list<Opcode> sequence;
	string s_fname;
	string hash_val;
	Family family;
	//void(*change_to_unique)(list<Opcode>&) = ctu;
	void change_to_unique() {
		//delete all dublicate
		sequence.sort(compare_opcodes);
		sequence.unique(equalence_of_opcodes);
	};
};
typedef enum FILETYPE {
	NOTSCANNED, BENIGN, DETECTED, SIGNED
};
struct File {
	File() : name(), hash(), ft(NOTSCANNED) {};
	File(string n) : name(n), hash(), ft(NOTSCANNED) {};
	string name;
	string hash;
	FILETYPE ft;
};
#endif